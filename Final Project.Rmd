---
title: "**Comparison of Matrix Algebra Computational Performance Between Base R and RcppEigen**"
author: "**Costa Stavrianidis**"
output: pdf_document
fontsize: 10pt
indent: true
classoption:
  - twocolumn
---

```{r setup, include=FALSE}
library(tidyverse)
library(RcppEigen)
library(microbenchmark)
library(foreach)
library(ggplot)
```

\begin{center}
\textbf{\Large Abstract}
\end{center}

\begin{small}
In this study, we compare the performance of various matrix algebra computations across functions in base R and functions created using the RcppEigen package. The goal is to quantify the efficiency differences between the two for computations that complete the same goal. 
\end{small}

\vspace{12pt}

\begin{center}
\textbf{\Large Introduction}
\end{center}
Compiled programming languages have their programs compiled into machine-readable instructions before execution. Examples of compiled languages include C, C++, Rust, and Fortran. Interpreted languages have their programs read and executed by an interpreter rather than translating the program into machine-readable instructions. Examples of interpreted languages include Python, R, and JavaScript.

Both types of languages contain their own advantages and disadvantages. The advantage of creating a compiled program is that it is faster than an interpreted program at execution.

```{Rcpp, include=FALSE}
// Creating functions to compare with base R using RccpEigen
#include <Rcpp.h>
#include <RcppEigen.h>

using Eigen::MatrixXd;
using Eigen::VectorXd;
using Eigen::Map;
using Eigen::SelfAdjointEigenSolver;

//[[Rcpp::depends(RcppEigen)]]
//[[Rcpp::export]]

MatrixXd simmat(int nrow, int ncol, double mu, double sigma) {
  // Simulate a random matrix of dimension nrow  x ncol whose
  // entries are drawn independently from a Normal(mu, sigma) distribution
  MatrixXd matA(nrow, ncol);
  VectorXd randvec(nrow*ncol);
  randvec = Rcpp::as< Map<VectorXd> >(Rcpp::rnorm(nrow*ncol, mu,sigma));
  return Map<MatrixXd>(randvec.data(), nrow, ncol);
}

//[[Rcpp::depends(RcppEigen)]]
//[[Rcpp::export]]

MatrixXd elemmult(MatrixXd matA, MatrixXd matB) {
  // Function for element-wise matrix multiplication
  return matA.array() * matB.array();
}

//[[Rcpp::depends(RcppEigen)]]
//[[Rcpp::export]]

MatrixXd matrixmult(MatrixXd matA, MatrixXd matB) {
  // Function for matrix multiplication
  return matA * matB;
}

//[[Rcpp::depends(RcppEigen)]]
//[[Rcpp::export]]

MatrixXd eigentranspose(MatrixXd matA) {
  // Function for matrix transposition
  return matA.transpose();
}

//[[Rcpp::depends(RcppEigen)]]
//[[Rcpp::export]]

MatrixXd eigenvalues(MatrixXd matA) {
  // Function to compute eigenvalues
  SelfAdjointEigenSolver<MatrixXd> es(matA);
  return es.eigenvalues();
}

//[[Rcpp::depends(RcppEigen)]]
//[[Rcpp::export]]

MatrixXd eigeninv(MatrixXd matA) {
  // Function for Eigen inversion
  return matA.inverse();
}

//[[Rcpp::depends(RcppEigen)]]
//[[Rcpp::export]]

MatrixXd cholinv(MatrixXd matA) {
  // Function for Cholesky inversion
  return matA.llt().solve(MatrixXd::Identity(matA.rows(), matA.rows()));
}

//[[Rcpp::depends(RcppEigen)]]
//[[Rcpp::export]]

MatrixXd linearsolve(MatrixXd matA, VectorXd vecB) {
  // Function to solve linear equation Ax = b for vector x
  return matA.inverse() * vecB;
}
```

```{r, include=FALSE}
# Checking to see RcppEigen and R functions return same values
set.seed(100)
matA <- simmat(10, 10, 0, 1)
matB <- simmat(10, 10, 0, 1)
vecB <- rnorm(10)
# Make matrices symmetric
matA <- t(matA) %*% matA
matB <- t(matB) %*% matB

all.equal(elemmult(matA, matB), matA*matB)
all.equal(matrixmult(matA, matB), matA%*%matB)
all.equal(eigentranspose(matA), t(matA))
all.equal(rev(as.vector(eigenvalues(matA))), eigen(matA)$values)
all.equal(eigeninv(matA), solve(matA))
# Will not be equal because Cholesky inversion requires matrix to be positive definite
all.equal(cholinv(matA), chol2inv(matA))
all.equal(as.vector(linearsolve(matA, vecB)), solve(matA, vecB))
```

```{r, include=FALSE}
# Efficiency comparison using simulated matrices
set.seed(100)

# Time unit for benchmarking
timeunit <- "microseconds"

foreach::foreach(x = c(10L, 50L, 100L, 200L, 500L, 1000L), .combine = rbind) %do% {

  # Simulate symmetric random matrix
  matA <- simmat(x, x, 0, 1)
  matB <- simmat(x, x, 0, 1)
  matA <- t(matA) %*% matA
  matB <- t(matB) %*% matB
  vecB <- rnorm(x)
  
  # Conduct benchmark analysis
  microbenchmark(
    
    # RcppEigen functions
    eigen_elemmult = elemmult(matA, matB),
    eigen_matrixmult = matrixmult(matA, matB),
    eigen_transpose = eigentranspose(matA),
    eigen_eigenvalues = eigenvalues(matA),
    eigen_eigeninv = eigeninv(matA),
    eigen_cholinv = cholinv(matA),
    eigen_linearsolve = linearsolve(matA, vecB),
    
    # base R functions
    R_elemmult = matA * matB,
    R_matrixmult = matA %*% matB,
    R_transpose = t(matA),
    R_eigenvalues = eigen(matA),
    R_eigeninv = solve(matA),
    R_cholinv = chol2inv(matA),
    R_linearsolve = solve(matA, vecB),
    
    times = 10,
    unit = timeunit
    
  ) -> benchmark
  
  # return results
  data.frame(x, as.data.frame(benchmark))
  
} -> results
```
